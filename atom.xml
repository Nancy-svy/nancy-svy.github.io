<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://nancy-svy.github.io</id>
    <title>Gridea</title>
    <updated>2023-05-12T08:27:42.508Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://nancy-svy.github.io"/>
    <link rel="self" href="https://nancy-svy.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://nancy-svy.github.io/images/avatar.png</logo>
    <icon>https://nancy-svy.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[watch监听中的属性]]></title>
        <id>https://nancy-svy.github.io/post/watchListeningProperties/</id>
        <link href="https://nancy-svy.github.io/post/watchListeningProperties/">
        </link>
        <updated>2023-05-11T07:19:01.000Z</updated>
        <content type="html"><![CDATA[<pre><code>watch: {
        data: {
            // 监听数据 获取到数据里的数组数据
            handler(val) {
                this.getInfo()
            },
            // 深度监听
            deep: true, 
            // 在watch中首次绑定的时候，是否执行handler，值为true则表示在watch中声明的时候，就立即执行handler方法，值为false，则和一般使用watch一样，在数据发生变化的时候才执行handler。所以当为true时 在created周期里就可以不用在写
            immediate:true, 
        },
    },
    created() {
        // this.getInfo()     immediate: true包含了初始化时触发
    }

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue 关于Vue使用watch监听属性报“TypeError: Cannot read properties of undefined (reading ‘xxx‘)“的问题]]></title>
        <id>https://nancy-svy.github.io/post/watchAttributeError/</id>
        <link href="https://nancy-svy.github.io/post/watchAttributeError/">
        </link>
        <updated>2023-05-11T01:20:46.000Z</updated>
        <content type="html"><![CDATA[<h5 id="报错信息">报错信息</h5>
<p><strong>Error in callback for immediate watcher “abc”: &quot;TypeError: Cannot read properties of undefined (reading ‘xxx’)&quot;</strong><br>
<img src="https://nancy-svy.github.io/post-images/1683788865847.png" alt="" loading="lazy"></p>
<p><strong>解决方法：</strong></p>
<h5 id="1-watch当中的方法名写错">1、watch当中的方法名写错</h5>
<p>错误写法：</p>
<pre><code>watch: {
    $route: {
        immediate: true,
        headler() {  //  这里写错啦！
            console.log(111);
        },
    },
}
</code></pre>
<p>正确写法：</p>
<pre><code>watch: {
    $route: {
        immediate: true,
        handler() {
            console.log(111);
        },
    },
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://nancy-svy.github.io/post-images/1683789273221.png" alt="" loading="lazy"></figure>
<h5 id="2-当使用this指向data时报错使用普通函数">2、当使用this指向data时报错（使用普通函数）</h5>
<p>错误写法：</p>
<pre><code>$route: {
	immediate: true,
	handler: (route) =&gt; {
		console.log(this.route);
	},
},

</code></pre>
<p>正确写法：</p>
<pre><code>$route: {
   immediate: true,
   handler: function (route) {
       console.log(this.route);
   },
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue 表格数据打印功能]]></title>
        <id>https://nancy-svy.github.io/post/tableDataPrinting/</id>
        <link href="https://nancy-svy.github.io/post/tableDataPrinting/">
        </link>
        <updated>2023-05-09T03:16:31.000Z</updated>
        <content type="html"><![CDATA[<h4 id="一-单页打印">一、单页打印</h4>
<figure data-type="image" tabindex="1"><img src="https://nancy-svy.github.io/post-images/1683708395717.jpg" alt="" loading="lazy"></figure>
<p>只对当前页面可见数据进行打印，实现方法不唯一，此处介绍相对简单的vue-print-nb。他的缺点是只能打印可见区域，不能分页打印 。</p>
<ol>
<li>安装</li>
</ol>
<pre><code>  npm install vue-print-nb --save
</code></pre>
<ol start="2">
<li>引入</li>
</ol>
<pre><code>// 安装好以后在main.js文件中引入
import Print from 'vue-print-nb'
Vue.use(Print);  //注册
</code></pre>
<ol start="3">
<li>使用<br>
(1). 直接使用id，不对最终打印的表格进行样式修改</li>
</ol>
<pre><code>// 通过ID直接打印
  &lt;div id=&quot;print_demo&quot; &gt;
    &lt;p&gt;打印内容&lt;/p&gt;
  &lt;/div&gt;
&lt;button v-print=&quot;'#print_demo'&quot;&gt;打印&lt;/button&gt;
</code></pre>
<p>(2). 使用printObj，可以对打印的表格进行样式调整</p>
<pre><code>// 在组件的打印按钮标签上使用指令 v-print=&quot;printObj&quot;, print是配置对象
  &lt;button v-print=&quot;printObj&quot;&gt;打印&lt;/button&gt;

//  在组件的打印区域标签上加 id=&quot;print_demo&quot;
&lt;div id=&quot;print_demo&quot;  style=&quot;background:red;&quot;&gt;
  &lt;p&gt;打印内容&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>(2-1). 在组件的data中定义print配置对象</p>
<pre><code>export default {
    data() {
        return {
            printObj: {
              id: &quot;print_demo&quot;,
              popTitle: '打印的标题', //  打印配置页上方标题
              extraHead: '&lt;meta http-equiv=&quot;Content-Language&quot;content=&quot;zh-cn&quot;/&gt;',  // 最上方的头部文字，附加在head标签上的额外标签,使用逗号分隔
               preview: '',  // 是否启动预览模式，默认是false（开启预览模式，可以先预览后打印）
               previewTitle: '',  // 打印预览的标题（开启预览模式后出现）,
               previewPrintBtnLabel: '',  // 打印预览的标题的下方按钮文本，点击可进入打印（开启预览模式后出现）
               zIndex: '', // 预览的窗口的z-index，默认是 20002（此值要高一些，这涉及到预览模式是否显示在最上面）   
               previewBeforeOpenCallback() {}, //预览窗口打开之前的callback（开启预览模式调用）
               previewOpenCallback() {}, // 预览窗口打开之后的callback（开启预览模式调用）
               beforeOpenCallback() {}, // 开启打印前的回调事件
               openCallback() {}, // 调用打印之后的回调事件
              closeCallback() {}, //关闭打印的回调事件（无法确定点击的是确认还是取消）
              extraCss: 'https://www.google.com,https://www.google.com', 
            }
        };
    }
}
</code></pre>
<p>(2-2). 打印过滤（隐藏打印区域不需要打印的内容）<br>
只需要在组件的打印区域里，给需要隐藏的内容的标签上添加</p>
<pre><code>class=&quot;noprint&quot;
</code></pre>
<p>(2-3). 配置打印的样式<br>
在全局样式中，新增<style media="print"></style>标签，里面是打印时才生效的样式</p>
<pre><code>&lt;style media=&quot;print&quot;&gt;
    @page {
    size: auto;
    margin: 3mm;
    }

    html {
    background-color: #ffffff;
    height: auto;
    margin: 0px;
    }
&lt;/style&gt;
</code></pre>
<p>(2-4). 处理常见的打印bug<br>
解决打印出现空白页的问题<br>
解决el-table表格内容过多，打印不全问题<br>
解决作用域污染问题导致el-table序号错位</p>
<pre><code>&lt;style media=&quot;print&quot; lang=&quot;scss&quot;&gt;
    @page {
    size: auto;
    margin: 3mm;
    }
    @media print {
    html {
        background-color: #ffffff;
        height: auto;
        margin: 0px;
    }

    body {
        border: solid 1px #ffffff;
        margin: 10mm 15mm 10mm 15mm;
    }
    table {
        table-layout: auto !important;
    }

    .el-table__header-wrapper .el-table__header {
        width: 100% !important;
        border: solid 1px #f2f2f2;
    }
    .el-table__body-wrapper .el-table__body {
        width: 100% !important;
    }
    #pagetable table {
        table-layout: fixed !important;
    }
    }
&lt;/style&gt;
</code></pre>
<p>(2-5). 局部打印，局限在当前组件里<br>
在组件标签</p>
<pre><code>&lt;style media=&quot;print&quot; lang=&quot;scss&quot;&gt;
@page {
  size: auto;
  margin: 3mm;
}
@media print {
  html {
    background-color: #ffffff;
    height: auto;
    margin: 0px;
  }

  body {
    border: solid 1px #ffffff;
    margin: 10mm 15mm 10mm 15mm;
  }
  #printArea table {
    table-layout: auto !important;
  }

  #printArea .el-table__header-wrapper .el-table__header {
    width: 100% !important;
    border: solid 1px #f2f2f2;
  }
  #printArea .el-table__body-wrapper .el-table__body {
    width: 100% !important;
  }
  #printArea #pagetable table {
    table-layout: fixed !important;
  }
}
&lt;/style&gt;
</code></pre>
<p>(2-6). 注意<br>
启动打印后可以通过调整设置的缩放来调整显示比例<br>
可以通过设置背景图形来控制页面是否使用彩色背景</p>
<h4 id="二-打印数据库内全部数据">二、打印数据库内全部数据</h4>
<p><a href="https://printjs.crabbly.com/">Print.js 文档</a></p>
<figure data-type="image" tabindex="2"><img src="https://nancy-svy.github.io/post-images/1683697863113.png" alt="" loading="lazy"></figure>
<p>将数据库内的全部数据以表格的形式进行打印，需要调用后台接口直接从数据库内进行数据的查找，而不是直接在页面内获取数据。</p>
<ol>
<li>安装</li>
</ol>
<pre><code>npm install print-js --save
</code></pre>
<ol start="2">
<li>引入</li>
</ol>
<pre><code>// 在当前vue文件内引用
import printJS from 'print-js'
</code></pre>
<ol start="3">
<li>使用</li>
</ol>
<pre><code>&lt;el-button  @click=&quot;printJson&quot;&gt;打印全部表格&lt;/el-button&gt;
</code></pre>
<pre><code>async printJson() {
      //通过getdata调用后台接口获取数据封装到res
      const res = await getdata();
      this.list = res.data || [];
      printJS({
        printable: this.list ,
        properties: [ // 表头数据
          {
            field: 'num', //  表头字段
            displayName: '序号', // 页面显示的文字
          },
          { field: 'date', displayName: '日期 '},
         { field: 'name', displayName: '费用名称' },
         { field: 'subjectMatter', displayName: '事由' },
         { field: 'money', displayName: '金额(元)' },
         { field: 'notes', displayName: '备注' },
        ],
        type: 'json',
         // tbody的样式
        gridStyle: 'text-align: center;border: 1px solid #E5E6EB;' ,
         // 标题
		header: `&lt;h3 class=&quot;custom-h3&quot;&gt;标题&lt;/h3&gt;`,
        // 标题样式
		style: '.custom-h3{text-align: center; margin-bottom: 10px;}',
      })
    },
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue 条形码]]></title>
        <id>https://nancy-svy.github.io/post/barCode/</id>
        <link href="https://nancy-svy.github.io/post/barCode/">
        </link>
        <updated>2023-05-09T02:19:36.000Z</updated>
        <content type="html"><![CDATA[<h5 id="一-jsbarcode">一、JsBarcode</h5>
<p><a href="https://lindell.me/JsBarcode/">JsBarcode 文档</a></p>
<ol>
<li>安装：</li>
</ol>
<pre><code>npm install jsbarcode --save
</code></pre>
<ol start="2">
<li>引入：在需要生成条形码的页面引入即可</li>
</ol>
<pre><code>import JsBarcode from 'jsbarcode'
</code></pre>
<ol start="3">
<li>需要显示条形码的页面里</li>
</ol>
<pre><code>&lt;img id=&quot;barcode1&quot;&gt;
</code></pre>
<ol start="4">
<li>调用构造函数生成条形码</li>
</ol>
<pre><code>let barCode1 = this.info.marIdCode;
let barheight = this.imgHeight;
JsBarcode(&quot;#barcode1&quot;,barCode1,{
    format:&quot;CODE128&quot;, // 条形码的格式
    width:1,  // 线宽
    height:barheight,  // 条码高度
    lineColor:&quot;#000&quot;,  // 线条颜色
    displayValue:false,  // 是否显示文字
    margin:2  // 设置条形码周围的空白区域
})
</code></pre>
<h5 id="二-vue-barcode">二、vue-barcode</h5>
<p>vue-barcode 是JsBarcode的简单包装</p>
<ol>
<li>版本一<br>
<a href="https://github.com/lindell/vue-barcode">https://github.com/lindell/vue-barcode</a><br>
安装</li>
</ol>
<pre><code>npm install vue-barcode
</code></pre>
<ol start="2">
<li>版本二<br>
<a href="https://github.com/xkeshi/vue-barcode">https://github.com/xkeshi/vue-barcode</a><br>
安装</li>
</ol>
<pre><code>npm install @xkeshi/vue-barcode 
</code></pre>
<ol start="3">
<li>两个版本区别</li>
</ol>
<p>版本一：只能单独绑定属性<br>
引入：在需要生成条形码的页面引入即可</p>
<pre><code> import  VueBarcode from 'vue-barcode'
 new Vue({
  components: {
      'barcode': VueBarcode
  }
})
</code></pre>
<pre><code>&lt;barcode  :value=&quot;barcodeValue&quot;  :width=&quot;7&quot;  :height=&quot;200&quot;&gt;&lt;/barcode&gt;
</code></pre>
<p>版本二：可直接options绑定所有属性<br>
引入：在需要生成条形码的页面引入即可</p>
<pre><code> import VueBarcode from '@xkeshi/vue-barcode'
 new Vue({
  components: {
      'barcode': VueBarcode
  }
})
</code></pre>
<pre><code>&lt;barcode  :value=&quot;barcodeValue&quot;  :options=&quot;{ width:100 , height:100}&quot;&gt;
    条形码显示失败时的内容
&lt;/barcode&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js  文件大小换算为B、KB、MB、GB]]></title>
        <id>https://nancy-svy.github.io/post/fileSizeConversion/</id>
        <link href="https://nancy-svy.github.io/post/fileSizeConversion/">
        </link>
        <updated>2023-05-07T01:46:22.000Z</updated>
        <content type="html"><![CDATA[<pre><code>// 文件大小换算
			sizeTostr(size) {
			    var data = &quot;&quot;;
			    if (size &lt; 0.1 * 1024) { // 如果小于0.1KB转化成B  
			        data = size.toFixed(2) + &quot;B&quot;;
			    } else if (size &lt; 0.1 * 1024 * 1024) { // 如果小于0.1MB转化成KB  
			        data = (size / 1024).toFixed(2) + &quot;KB&quot;;
			    } else if (size &lt; 0.1 * 1024 * 1024 * 1024) { // 如果小于0.1GB转化成MB  
			        data = (size / (1024 * 1024)).toFixed(2) + &quot;MB&quot;;
			    } else { //其他转化成GB  
			        data = (size / (1024 * 1024 * 1024)).toFixed(2) + &quot;GB&quot;;
			    }
			    var sizestr = data + &quot;&quot;;
			    var len = sizestr.indexOf(&quot;\.&quot;);
			    var dec = sizestr.substr(len + 1, 2);
			    if (dec == &quot;00&quot;) { // 当小数点后为00时 去掉小数部分  
			        return sizestr.substring(0, len) + sizestr.substr(len + 3, 2);
			    }
			    return sizestr;
			},
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[uniapp用post上传图片流binary]]></title>
        <id>https://nancy-svy.github.io/post/postUploadImageStreamBinary/</id>
        <link href="https://nancy-svy.github.io/post/postUploadImageStreamBinary/">
        </link>
        <updated>2023-05-07T01:23:44.000Z</updated>
        <content type="html"><![CDATA[<p>注意：<br>
1.uniapp对request请求有封装，会对入参进行格式化，如果想post主体为图片流，不能直接用；<br>
2.传binary需要将路径转为base64，再转为二进制流blob</p>
<p>引入图片路径转base64</p>
<pre><code>import {pathToBase64} from &quot;image-tools&quot;;
</code></pre>
<p>选择图片时转base64</p>
<pre><code>        uni.chooseImage({
          count: 1, //最多可以选择的图片张数				  count: 1, //默认100
          extension:['.jpg','.png','.jpeg','.gif','.svg','.webp','.jfif','.bmp','.dpg'],
          sizeType: ['compressed'], //original 原图，compressed 压缩图
          sourceType: ['album', 'camera'], //album 从相册选图，camera 使用相机
          //成功则返回图片的本地文件路径列表 tempFilePaths
          success: (res) =&gt; {
            this.imageList = this.imageList.concat(res.tempFilePaths);//成功后利用concat方法追加到imageList1中
            //循环遍历res.tempFilePaths将每一个图像路径转换为base64
            for (var i = 0; i &lt; res.tempFilePaths.length; i++) {
              pathToBase64(res.tempFilePaths[i])
                .then(path =&gt; {
                  this.baseImageList = this.baseImageList.concat(path);//成功后利用concat方法追加到baseImageList中
                })
                .catch(error =&gt; {
                  console.error(error)
                })
            }
          }
        })
</code></pre>
<p>base64转二进制流</p>
<pre><code> 
      /**
       * Base64字符串转二进制流
       * @param {String} dataurl Base64字符串(字符串包含Data URI scheme，例如：data:image/png;base64, )
       */
      dataURLtoBlob(dataurl) {
        var arr = dataurl.split(&quot;,&quot;),
            mime = arr[0].match(/:(.*?);/)[1],
            bstr = atob(arr[1]),
            n = bstr.length,
            u8arr = new Uint8Array(n);
        while (n--) {
          u8arr[n] = bstr.charCodeAt(n);
        }
        return new Blob([u8arr], {
          type: mime,
        });
      },
</code></pre>
<p>请求接口</p>
<pre><code> 
      async upload(url, binary){
        var xhr = new XMLHttpRequest();
        xhr.open(&quot;POST&quot;, url, false);
        xhr.overrideMimeType(&quot;application/octet-stream&quot;);
        //直接发送二进制数据
        if(xhr.sendAsBinary){
          xhr.sendAsBinary(binary);
        }else{
          xhr.send(binary);
        }
        // 监听变化
        if(xhr.status===200){
          // 响应成功
          return  xhr.response
        } else {
          this.$utils.showToast(xhr.responseText, &quot;none&quot;)
          return;
        },
</code></pre>
<p>上传至服务器</p>
<pre><code>let url = '**************'
let file = this.base64toFile(this.baseImageList[0], url);
let fileid = '';
let result = await this.upload(url, file);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[google 简书广告屏蔽]]></title>
        <id>https://nancy-svy.github.io/post/blockAdvertising/</id>
        <link href="https://nancy-svy.github.io/post/blockAdvertising/">
        </link>
        <updated>2023-05-06T05:36:40.000Z</updated>
        <content type="html"><![CDATA[<p>最近简书感觉是穷疯了，随便打开一篇文章满屏的广告乱飞，对于有强迫症的患者非常难受，看到广告就想点 x x 关闭。似乎简书与我干上了，并不希望我关闭广告，点完关闭立马把我带到广告的详情页，于是忍无可忍从网上找了一些方法，彻底铲除这些辣眼睛的广告。<br>
<img src="https://nancy-svy.github.io/post-images/1683351463792.png" alt="" loading="lazy"></p>
<p><strong>一、 AdGuard 广告拦截器</strong><br>
<a href="http://www.ddooo.com/softdown/128398.htm">AdGuard</a> 广告拦截器是一款可以对抗各式广告的拦截插件，该插件可以拦截包括视频广告、浮动广告以及插播广告在内的绝大部分常见的网站广告。<br>
<img src="https://nancy-svy.github.io/post-images/1683351546969.png" alt="" loading="lazy"></p>
<p><strong>二、 Adblock</strong><br>
<a href="https://adblockplus.org/">AdBlock</a> 插件是 Chrome 最知名的广告拦截插件之一，不仅能够帮助用户对 Facebook 和 YouTube 等网站上的广告、弹窗和恼人的横幅广告进行拦截，同时也能够对第三方跟踪代码进行拦截，保护用户的隐私。<br>
<img src="https://nancy-svy.github.io/post-images/1683351602470.png" alt="" loading="lazy"></p>
<p><strong>三、Adblock plus</strong><br>
<a href="https://www.adblockplus.org/">Adblock Plus</a> 插件作为一款功能强大且免费的广告拦截插件，支持包括 Chrome 、 Firefox 等在内的多种浏览器。<br>
在浏览器中安装、启用该插件后，用户不需要操作，它就会对网页中的广告进行自动屏蔽，并且还会将空白的页面进行合并，完全看不出广告的痕迹。<br>
<img src="https://nancy-svy.github.io/post-images/1683351815771.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[elementUI tree组件]]></title>
        <id>https://nancy-svy.github.io/post/elementUITree/</id>
        <link href="https://nancy-svy.github.io/post/elementUITree/">
        </link>
        <updated>2023-04-28T08:01:00.000Z</updated>
        <content type="html"><![CDATA[<p><strong>1. 改变tree的背景色</strong></p>
<pre><code>::v-deep .el-tree{
  background-color: #f5f5f5;
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://nancy-svy.github.io/post-images/1682669162227.png" alt="" loading="lazy"></figure>
<p><strong>2. tree组件鼠标hover悬浮背景色</strong></p>
<pre><code>::v-deep.el-tree-node__content{
  &amp;:hover{
    background-color: red;
  }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://nancy-svy.github.io/post-images/1682669133861.png" alt="" loading="lazy"></figure>
<p><strong>3. tree组件选中背景色修改</strong></p>
<pre><code>::v-deep.el-tree-node.is-current &gt; .el-tree-node__content {
    background-color: black !important;
  }
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://nancy-svy.github.io/post-images/1682669104470.png" alt="" loading="lazy"></figure>
<p><strong>4.tree组件设置图标</strong></p>
<pre><code>    ::v-deep.tree{
        .el-tree-node__expand-icon.expanded {
            -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
        }
        // 收起
        .el-icon-caret-right:before {
            content: '\e6d9';       
            border: 1px solid #999999;			   
        }
        // 展开
        .el-tree-node__expand-icon.expanded.el-icon-caret-right:before {
            content: '\e6d8';
            color: #165DFF;
            border: 1px solid #165DFF;
        }
        .el-tree-node__expand-icon.is-leaf:before  {
            content: '' !important;
            border: none;
        }
    }
</code></pre>
<p>实现效果<br>
<img src="https://nancy-svy.github.io/post-images/1682669221905.png" alt="" loading="lazy"></p>
<p><strong>5. tree组件有指示线</strong><br>
实现效果<br>
<img src="https://nancy-svy.github.io/post-images/1683339530196.png" alt="" loading="lazy"></p>
<pre><code>&lt;el-tree
    class=&quot;tree-line&quot;
    :data=&quot;data&quot;
    show-checkbox
    node-key=&quot;id&quot;
    :props=&quot;defaultProps&quot;
&gt;
&lt;/el-tree&gt;
</code></pre>
<p>css样式</p>
<pre><code>.tree-line{
    .el-tree-node {
        position: relative;
        padding-left: 16px;
    }
    .el-tree-node__content {
        margin-top: 10px;
    }
    .el-tree-node__children {
        padding-left: 16px;
    }
    .el-tree-node::before {
        content: '';
        height: 100%;
        width: 1px;
        position: absolute;
        left: -3px;
        top: -26px;
        border-width: 1px;
        border-left: 1px dashed #707070;
    }
    
    .el-tree-node:last-child::before {
        height: 38px;
    }
    .el-tree-node::after {
        content: '';
        width: 24px;
        height: 20px;
        position: absolute;
        left: -3px;
        top: 12px;
        border-width: 1px;
        border-top: 1px dashed #707070;
    }
    &amp; &gt; .el-tree-node::after {
        border-top: none;
    }
    &amp; &gt; .el-tree-node::before {
        border-left: none;
    }
    .el-tree-node__expand-icon {
        color: #000;
        &amp;.is-leaf {
        color: transparent;
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue-element-admin集成项目]]></title>
        <id>https://nancy-svy.github.io/post/vueElementAdminProject/</id>
        <link href="https://nancy-svy.github.io/post/vueElementAdminProject/">
        </link>
        <updated>2023-04-26T07:02:27.000Z</updated>
        <content type="html"><![CDATA[<h5 id="一-在其它网站下载的svg的图片有fill属性">一. 在其它网站下载的svg的图片，有fill属性</h5>
<p>设置不了svg的颜色，需要去掉fill属性</p>
<h5 id="二-vue-element-admin-修改页面标题">二、vue-element-admin 修改页面标题</h5>
<p><strong>1.找到permission.js页面</strong><br>
其中document.title = getPageTitle(to.meta.title)就是设置title<br>
然后找到getPageTitle方法,按住Ctrl键左键单击getPageTitle方法跳转到get-page-title.js文件界面<br>
<img src="https://nancy-svy.github.io/post-images/1683339152913.png" alt="" loading="lazy"></p>
<p><strong>2.找到get-page-title.js</strong><br>
<img src="https://nancy-svy.github.io/post-images/1683339184366.png" alt="" loading="lazy"></p>
<p><strong>3.再找到settings.js</strong><br>
修改默认的title<br>
<img src="https://nancy-svy.github.io/post-images/1683339196890.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue项目运行时遇到的问题]]></title>
        <id>https://nancy-svy.github.io/post/projectOperationIssues/</id>
        <link href="https://nancy-svy.github.io/post/projectOperationIssues/">
        </link>
        <updated>2023-04-20T02:29:30.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-module-build-failed-from-node_modulesless-loaderdistcjsjs-typeerror-thisgetoptions">一.  Module build failed (from ./node_modules/less-loader/dist/cjs.js): TypeError: this.getOptions</h3>
<p><strong>解决方法</strong><br>
降低less-loader的版本为7.3.0<br>
npm install less-loader@7.3.0 --save-dev</p>
<h3 id="二-vue-error-index-is-defined-but-never-used-vueno-unused-vars">二.  vue error ‘index‘ is defined but never used vue/no-unused-vars</h3>
<p>在运行vue项目时，界面写了个一个for循环，但是却报错。界面关键部分代码如下。因为index没有使用过，所以报错<br>
<img src="https://nancy-svy.github.io/post-images/1681958282676.png" alt="" loading="lazy"></p>
<p><strong>原因分析</strong><br>
应该是eslint校验导致的，开始想改变eslint校验规则，但是那个没有起效。于是换了一种办法新建vue.config.js文件，然后加入以下代码。重新运行后即可。</p>
<pre><code>module.exports = {
     lintOnSave: false
}
</code></pre>
<p>关于lintOnsave的解释可点击查看详细配置哦~<a href="https://cli.vuejs.org/zh/config/#pages">配置参考</a><br>
<img src="https://nancy-svy.github.io/post-images/1681958383332.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>